# Copyright 2014 The ALIVe authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse, collections, glob, re, sys, time
from common import *
from language import *
from parser import parse_llvm, parse_opt_file


def block_model(s, m):
  s.add(Not(And([Int(str(n)) == m[n] for n in m.decls()])))


def get_z3_id(x):
  return Z3_get_ast_id(x.ctx.ref(), x.as_ast())


def z3_solver_to_smtlib(s):
  a = s.assertions()
  size = len(a) - 1
  _a = (Ast * size)()
  for k in range(size):
    _a[k] = a[k].as_ast()

  return Z3_benchmark_to_smtlib_string(a[size].ctx_ref(), None, None, None, '',
                                       size, _a,  a[size].as_ast())


def gen_benchmark(s):
  if not os.path.isdir('bench'):
    return

  header = ("(set-info :source |\n Generated by ALIVe 0.1\n"
            " More info in TBD.\n|)\n\n")
  string = header + z3_solver_to_smtlib(s)

  files = glob.glob('bench/*.smt2')
  if len(files) == 0:
    filename = 0
  else:
    files.sort(reverse=True)
    filename = int(re.search('(\d+)\.smt2', files[0]).group(1)) + 1
  filename = 'bench/%03d.smt2' % filename
  fd = open(filename, 'w')
  fd.write(string)
  fd.close()


def getSolver(qvars):
  if qvars == []:
    return SolverFor('QF_BV')
  return SolverFor('BV')


def check_incomplete_solver(res, s):
  if res == unknown:
    print '\nWARNING: The SMT solver gave up. Verification incomplete.'
    print 'Solver says: ' + s.reason_unknown()
    exit(-1)


correct_exprs = {}
def check_expr(qvars, expr, extra, error):
  expr = mk_forall(qvars, expr)
  id = get_z3_id(expr)
  if id in correct_exprs:
    return
  correct_exprs[id] = expr

  s = getSolver(qvars)
  s.add(extra)
  s.add(expr)

  if __debug__:
    gen_benchmark(s)

  res = s.check()
  if res != unsat:
    check_incomplete_solver(res, s)
    e, src, tgt, stop, srcv, tgtv, types = error(s)
    print '\nERROR: %s' % e
    print 'Example:'
    print_var_vals(s, srcv, tgtv, stop, types)
    print 'Source value: ' + src
    print 'Target value: ' + tgt
    exit(-1)


def var_type(var, types):
  t = types[Int('t_' + var)].as_long()
  if t == Type.Int:
    return 'i%s' % types[Int('size_' + var)]
  if t == Type.Ptr:
    return var_type('*' + var, types) + '*'
  assert False


def str_model(s, v):
  val = s.model().evaluate(v, True).as_long()
  return "%d (%s)" % (val, hex(val))


def _print_var_vals(s, vars, stopv, seen, types):
  for k,v in vars.iteritems():
    if k == stopv:
      return
    if k in seen:
      continue
    seen |= set([k])
    print "%s %s = %s" % (k, var_type(k, types), str_model(s, v[0]))


def print_var_vals(s, vs1, vs2, stopv, types):
  seen = set()
  _print_var_vals(s, vs1, stopv, seen, types)
  _print_var_vals(s, vs2, stopv, seen, types)


def check_opt(src, tgt, types):
  srcv = toSMT(src)
  tgtv = toSMT(tgt)
  extra_cnstrs = [srcv.getAllocaConstraints(),
                  tgtv.getAllocaConstraints()]

  for k,v in srcv.iteritems():
    # skip instructions only on one side; assumes they remain unchanged
    if not tgtv.has_key(k):
      continue

    (a, defa, qvars) = v
    (b, defb, qvarsb) = tgtv[k]
    defa = mk_and(defa)
    defb = mk_and(defb)

    # Check if domain of defined values of Src implies that of Tgt.
    check_expr(qvars, And(defa, Not(defb)), extra_cnstrs, lambda s :
      ("Domain of definedness of Target is smaller than Source's for %s %s\n"
         % (var_type(k, types), k),
       str_model(s, a), 'undef', k, srcv, tgtv, types))

    # Check that final values of vars are equal.
    check_expr(qvars, And(defa, a != b), extra_cnstrs, lambda s :
      ("Mismatch in values of %s %s\n" % (var_type(k, types), k),
       str_model(s, a), str_model(s, b), k, srcv, tgtv, types))

  # now check that the final memory state is similar in both programs
  memsb = {str(ptr) : mem for (ptr, mem, info) in tgtv.ptrs}
  for (ptr, mem, info) in srcv.ptrs:
    memb = memsb.get(str(ptr))
    if memb == None:
      # If memory was not written in Source, then ignore the block.
      if is_const(simplify(mem)):
        continue
      print '\nERROR: No memory state for %s in Target' % str(ptr)
      exit(-1)

    check_expr([], mem != memb, extra_cnstrs, lambda s :
      ('ERROR: Mismatch in final memory state for %s (%d bits)' %
         (ptr, mem.sort().size()),
       str_model(s, mem), str_model(s, memb), None, srcv, tgtv, types))


def main():
  file = sys.stdin.read()
  data = parse_opt_file(file)

  src = collections.OrderedDict()
  parse_llvm(data[0], src)

  tgt = collections.OrderedDict()
  parse_llvm(data[1], tgt)

  print 'Source:'
  print_prog(src)

  print '\nTarget:'
  print_prog(tgt)
  print

  # infer allowed types for registers
  type_vars = []
  type_src = getTypeConstraints(src, type_vars)
  type_tgt = getTypeConstraints(tgt, type_vars)

  s = Solver()
  s.add(type_src)
  if s.check() != sat:
    print 'Source program does not type check'
    exit(-1)

  s.add(type_tgt)
  if s.check() != sat:
    print 'Source and Target programs do not type check'
    exit(-1)


  # now check for correctness
  proofs = 0
  while s.check() == sat:
    types = s.model()
    fixupTypes(src, types)
    fixupTypes(tgt, types)
    check_opt(src, tgt, types)
    block_model(s, types)
    proofs += 1
    sys.stdout.write('\rDone: ' + str(proofs))
    sys.stdout.flush()

  print '\nOptimization is correct!'
  if s.check() != unsat:
    print 'Note: verification incomplete; did not check all bit widths'


if __name__ == "__main__":
  try:
    main()
  except KeyboardInterrupt:
    print '\nCaught Ctrl-C. Exiting..'
